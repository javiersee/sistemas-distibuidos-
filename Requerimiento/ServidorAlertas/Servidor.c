/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "alertas.h"
#include "notificaciones.h"
#include "funcionesIndicador.h"
#include <string.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>

struct registrosTxt
{
     char fecha[30];
     char hora[30];
     int puntuacion;
};


bool_t *
enviarindicador_1_svc(nodo_paciente *argp, struct svc_req *rqstp)
{
	static bool_t  result;
	CLIENT *clnt;
	bool_t  *result_1;
	char * mensajeAEnviar =" notificacon la frecuencia ";
	
	char *dirIpServidorNotificaciones="localhost";

	alerta objAlerta;

	for (int i = 0; i < 6; i++)
	{
		
		objAlerta.ultimasAlertas[i].puntuacion=0;
		
	}
	for (int i = 0; i < 7; i++)
	{
		strcpy(objAlerta.generoAlerta[i].nombreIndicador,"null");
		
		
	}
	//Extraer informacion personal del objeto y asignarla al objeto objAlerta
	char nombrePaciente[50];
	//Nombre y apellidos
	strcpy(objAlerta.paciente.nombres,(*argp).nombres);
	//Numero de habitación
	objAlerta.paciente.numHabitacion = (*argp).numHabitacion;
	//Edad
	objAlerta.paciente.edad = (*argp).edad;

	//Gestión de la hora y  fecha, la cual se asignará a la alerta (objAlerta)
	
	time_t t;
	struct tm *tm;
	char fechayhora[15];
	t=time(NULL);
	tm=localtime(&t);
	
	strftime(fechayhora, sizeof(fechayhora), "%H:%M:%S", tm);
	printf("***Alerta Generada***\n\n");
	printf ("Hora del sistema: %s\n", fechayhora);
	//Agrego la hora a la alerta(objAlerta)
	strcpy(objAlerta.hora, fechayhora);

	

	strftime(fechayhora, sizeof(fechayhora), "%d-%m-%y", tm);
	printf ("Fecha del sistema: %s\n", fechayhora);
	//Agrego la hora a la alerta(objAlerta)
	strcpy(objAlerta.fecha, fechayhora);
	
	/*La variable puntución almacena el número de alertas que el paciente tuvo con base en sus indicadores.
 	  El método calcularPuntuacion, recibe como parámetro el objAlerta, con el fin de ir almacenando en dicho en si mismo los 
	  indicadores que generaron la alerta además de guardar su correspondiente valor. Ésta función retorna la cantidad de alertas
	  que fueron generadas */
	int puntacion = calcularPuntuacion(&objAlerta,(*argp));
	
	/*Asi, al pasar esta función ya tenemos en el objAlerta la información de los indicadores que no se encontraban en los 
	  límites establecidos */

	//printf("\nCantidad de Alertas para el paciente %s: %d\n",(*argp).nombres, puntacion);
	char cadena[150];
	char numHabitacion[5];
	sprintf(cadena, "\n%d %s %s %d", objAlerta.paciente.numHabitacion,objAlerta.fecha,objAlerta.hora, puntacion);
	//printf("Registro de alerta: %s\n",cadena);
	
	
	if(puntacion>=2){
		//Guardamos el registro de la alerta en el archivo prueba.txt
		FILE *fp;
		fp = fopen ( "prueba.txt", "a+t" );
		fputs( cadena, fp );
		fclose(fp);
		//printf("\nRegistro guardado exitosamente...");

	}else{
		printf("\nEste paciente no registró mas de 2 alertas..El Registro NO se guardó.");	
	}

	
	//Esta primera lectura del archivo me sirve para saber cuantos registros con el mismo numero de habitacion tengo
	FILE *archivo;
 	char caracteres[100];
 	int cantidadRegistros=0;
 	archivo = fopen("prueba.txt","r");
 	if (archivo == NULL)
 		exit(1);
 	else
        {
 	    
 	    while (feof(archivo) == 0)
 	    {
			fgets(caracteres,100,archivo);
			char * pch;
			pch = strtok (caracteres," ");

			//La variable iterador me permite saber cuantas veces se está ejecutando el ciclo while
			int iterador=0;
			int bandera=0;
			while (pch != NULL)
			{
				//Si el numero de habitacion corresponde con el primer elemento , entonces es el cliente que buscamos
				char numHab[5];
				sprintf(numHab, "%d", objAlerta.paciente.numHabitacion);
				//printf ("\nElemento %d : %s\n",iterador, pch);
				char comparar[5];
				sprintf(comparar, "%s", pch);

				pch = strtok (NULL, " ");
				iterador= iterador+1;
				if(bandera==0){
					//Con este if estoy validando que solo muestre los elmentos del paciente con el numero de
					if((strcmp(comparar,numHab)!=0)){
							break;
					}
					bandera = bandera+1;
					cantidadRegistros = cantidadRegistros +1;
				}
			
 	    	}
           
        }
	}
    fclose(archivo);


	//printf("\n\n***Empezamos a guardar***\n\n");
	//printf("Cantidad de Registros para el paciente %s: %d\n",(*argp).nombres,cantidadRegistros);
	//Con esta segunda lectura y ya habiendo creado un vector del tamano de registros , puedo ir guardando los registros en un arreglo
	//Crear el arreglo dinamico
	typedef struct Registro {
		char fecha[100];
		char hora[100];
		char puntuacion[10];
	} RegistroFromTxt;

	RegistroFromTxt registros[cantidadRegistros];
	
	FILE *archivo2;
 	char caracteres2[100];
 	/*La variable posición vector servirá como indice al momento de guardar en el arreglo registros, el cual almacena las 5 
	  últimas alertas si las hay*/
	int posicionVector;
	posicionVector =0;

 	archivo2= fopen("prueba.txt","r");
 	if (archivo2 == NULL)
 		exit(1);
 	else
        {
// 	    printf("\nEl contenido del archivo de prueba es \n\n");
 	    while (feof(archivo2) == 0)
 	    {
			fgets(caracteres2,100,archivo2);
			//printf("\nLinea para dividir: %s",caracteres2);
			char * pch;
			pch = strtok (caracteres2," ");

			
			int iterador=0;
			int bandera=0;
			while (pch != NULL)
			{
				//Si el numero de habitacion corresponde con el primer elemento , entonces es el cliente que buscamos
				char numHab[5];
				sprintf(numHab, "%d", objAlerta.paciente.numHabitacion);
				//printf ("\nElemento %d : %s",iterador, pch);
				
				char comparar[5];
				sprintf(comparar, "%s", pch);

				pch = strtok (NULL, " ");
				iterador= iterador+1;

				//Este if es para validar si el numero de la habitacion del enfermo actual coincide con los del documento de texto
				if(bandera==0){
					/*Con este if estoy validando que solo muestre los elmentos del paciente con el numero de habitacion
					  si dado el caso no coincide, entonces salimos del ciclo while mediante break*/
					if((strcmp(comparar,numHab)!=0)){
							posicionVector =posicionVector -1;
							break;
					}
					//printf("Estamos en la primera vuelta y ya empezamos a obtener informacion del paciente	\n");
					bandera = bandera+1;
				}

				//Si el iterador es igual a 1, guarda la fecha
				if(iterador==1){
					strcpy(registros[posicionVector].fecha,pch);
				}
				//Si el iterador es igual a 1, guarda la hora
				if(iterador==2){
					strcpy(registros[posicionVector].hora,pch);
				}
				//Si el iterador es igual a 1, guarda el numero de alerta
				if(iterador==3){
					strcpy(registros[posicionVector].puntuacion,pch);
				}
 	    	}
			posicionVector = posicionVector+1;
           
        }
	}
    fclose(archivo2);
	/*
	printf("\n\nCantidad de Registros para el paciente %s: %d\n",(*argp).nombres,cantidadRegistros);
	printf("\n\n***DATOS DESDE EL STRUCT***\n\n");
	int k;
	for(k=0;k<cantidadRegistros;k++){
		printf("\nDesde el struct: %s %s %s",registros[k].fecha, registros[k].hora, registros[k].puntuacion);

	}*/
	
	//Como nosotros sabemos la cantidad de registros totales para un enfermo en particular, las ultimas 5 alertas seran las ultimas cinco posiciones del arreglo de struct
		
	int posicionUltimasCincoAlertas ;
	switch(cantidadRegistros)
	{
	case 0:
		//operaciones a realizar en caso de que a valga 0;
		printf("\n\nNo hay registros en el sistema.\n\n");
		break;
	case 1:
		//Solo tenemos un registro
		strcpy(objAlerta.ultimasAlertas[0].fecha, registros[0].fecha);
		strcpy(objAlerta.ultimasAlertas[0].hora, registros[0].hora);
		objAlerta.ultimasAlertas[0].puntuacion = atoi(registros[0].puntuacion);
		break;
	
	case 2:
		//Tenemos dos registros
		for (int i = 0; i < 2; i++)
		{
			strcpy(objAlerta.ultimasAlertas[i].fecha, registros[i].fecha);
			strcpy(objAlerta.ultimasAlertas[i].hora, registros[i].hora);
			objAlerta.ultimasAlertas[i].puntuacion = atoi(registros[i].puntuacion);
		}
		
		break;
	case 3:
		//Tenemos tres registros
		for (int i = 0; i < 3; i++)
		{
			strcpy(objAlerta.ultimasAlertas[i].fecha, registros[i].fecha);
			strcpy(objAlerta.ultimasAlertas[i].hora, registros[i].hora);
			objAlerta.ultimasAlertas[i].puntuacion = atoi(registros[i].puntuacion);
		}
		break;
	
	case 4:
		//Tenemos cuatro registros
		for (int i = 0; i < 4; i++)
		{
			strcpy(objAlerta.ultimasAlertas[i].fecha, registros[i].fecha);
			strcpy(objAlerta.ultimasAlertas[i].hora, registros[i].hora);
			objAlerta.ultimasAlertas[i].puntuacion = atoi(registros[i].puntuacion);
		}
		break;

	default:
		//en caso de que no se de ninguna de las anteriores hacer...
		//Podemos realizar la resta y asignar los regsitros
		
		posicionUltimasCincoAlertas = cantidadRegistros-5;
		int posicionInicial = cantidadRegistros-5;
		int i;
		i=0;
		for (posicionInicial; posicionInicial < cantidadRegistros; posicionInicial++)
		{
			//Asignacion
			//printf("\nBefore [%d] %s --- %s",i,objAlerta.ultimasAlertas[i].fecha, registros[posicionInicial].fecha);
			strcpy(objAlerta.ultimasAlertas[i].fecha, registros[posicionInicial].fecha);
			
			
			strcpy(objAlerta.ultimasAlertas[i].hora, registros[posicionInicial].hora);
			
			

			int numero = atoi(registros[posicionInicial].puntuacion);
			objAlerta.ultimasAlertas[i].puntuacion = numero;
				
			
			i = i+1;
		}
	}



	printf("\n\n");
	

#ifndef	DEBUG
	clnt = clnt_create (dirIpServidorNotificaciones, gestion_notificaciones, gestion_notificaciones_version, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (dirIpServidorNotificaciones);
		exit (1);
	}
#endif	/* DEBUG */

	/*Validar que la puntuacion sea 2 o 3, si es 2  el mensaje esta relacionado con la enfermera
	si es 3, el mensaja estaría relacionado con el doctor. Si la puntucación es mayor a 2, enviamos la notificación*/		
	if(puntacion > 1){
		
		//strcpy(objAlerta.mensajeNotificaciones, "TENEMOS 3 O MAS ALERTAS, LA ENFERMERA Y EL MEDICO DEBE REVISAR EL PACIENTE");
		if(puntacion==2){
			//strcpy(objAlerta.mensajeNotificaciones, "TENEMOS 2 ALERTA, LA ENFERMERA DEBE REVISAR EL PACIENTE");
		}

		//Recuperar los 5 ultimas alertas
		

		//Guardar la alerta en un archivo txt

		
		//Enviar el objAlerta
		result_1 = enviarnotificaciones_2_2(&objAlerta, clnt);
		if (result_1 == (bool_t *) NULL) {
			clnt_perror (clnt, "call failed");
		}
	}
	
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	return &result;
}
